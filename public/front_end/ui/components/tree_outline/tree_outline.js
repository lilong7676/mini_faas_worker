import*as e from"../../../core/platform/platform.js";import*as t from"../../lit-html/lit-html.js";import*as r from"../code_highlighter/code_highlighter.js";import*as n from"../helpers/helpers.js";import*as o from"../render_coordinator/render_coordinator.js";const i=new CSSStyleSheet;function d(e){return"children"in e}i.replaceSync(':host{--list-group-padding:16px}li{list-style:none;text-overflow:ellipsis;min-height:12px}.tree-node-key{white-space:var(--override-key-whitespace-wrapping);min-width:0}.arrow-icon{display:block;user-select:none;-webkit-mask-image:var(--image-file-treeoutlineTriangles);-webkit-mask-size:32px 24px;-webkit-mask-position:0 0;background-color:var(--color-text-primary);content:"";text-shadow:none;height:12px;width:13px;overflow:hidden}ul{margin:0;padding:0}ul[role=group]{padding-left:var(--list-group-padding)}li:not(.parent)>.arrow-and-key-wrapper>.arrow-icon{-webkit-mask-size:0}li.parent.expanded>.arrow-and-key-wrapper>.arrow-icon{-webkit-mask-position:-16px 0}li.is-top-level{border-top:var(--override-top-node-border)}li.is-top-level:last-child{border-bottom:var(--override-top-node-border)}:host([animated]) li:not(.is-top-level){animation-name:slideIn;animation-duration:150ms;animation-timing-function:cubic-bezier(0,0,0.3,1);animation-fill-mode:forwards}@keyframes slideIn{from{transform:translateY(-5px);opacity:0%}to{transform:none;opacity:100%}}.arrow-and-key-wrapper{border:2px solid transparent;display:flex;align-content:center;align-items:center}[role=treeitem]:focus{outline:0}[role=treeitem].selected>.arrow-and-key-wrapper{background-color:var(--legacy-item-selection-bg-color)}\n/*# sourceURL=treeOutline.css */\n');class s extends t.Directive.Directive{constructor(e){if(super(e),e.type!==t.Directive.PartType.ATTRIBUTE)throw new Error("TrackDOMNodeToTreeNode directive must be used as an attribute.")}update(e,[t,r]){const n=e.element;if(!(n instanceof HTMLLIElement))throw new Error("trackTreeNodeToDOMNode must be used on <li> elements.");t.set(n,r)}render(e,t){}}const a=t.Directive.directive(s),l=e=>{const t=e.parentElement?.parentElement;if(t&&t instanceof HTMLLIElement){const e=t.nextElementSibling;return e&&e instanceof HTMLLIElement?e:l(t)}return null},c=e=>{const t=e.querySelector(':scope > [role="group"] > [role="treeitem"]:first-child');if(!t)throw new Error("Could not find child of expanded node.");return t},h=e=>null!==e.getAttribute("aria-expanded"),p=e=>h(e)&&"true"===e.getAttribute("aria-expanded"),u=e=>{const t=e.querySelector(':scope > [role="group"] > [role="treeitem"]:last-child');if(!t)throw new Error("Could not find child of expanded node.");return p(t)?u(t):t},f=e=>{let t=e.parentElement;if(!t)return null;for(;t&&"treeitem"!==t.getAttribute("role")&&t instanceof HTMLLIElement==!1;)t=t.parentElement;return t},m=new WeakMap,N=async e=>{if(!e.children)throw new Error("Asked for children of node that does not have any children.");const t=m.get(e);if(t)return t;const r=await e.children();return m.set(e,r),r},w=async(e,t)=>{for(const r of e){const e=await g(r,t,[r]);if(null!==e)return e}return null},g=async(e,t,r)=>{if(e.id===t)return r;if(e.children){const n=await N(e);for(const e of n){const n=await g(e,t,[...r,e]);if(null!==n)return n}}return null},v=e=>{const{currentDOMNode:t,currentTreeNode:r,direction:n,setNodeExpandedState:o}=e;if(!r)return t;if("ArrowDown"===n){if(p(t))return c(t);const e=(e=>{const t=e.nextElementSibling;return t&&t instanceof HTMLLIElement?t:null})(t);if(e)return e;const r=l(t);if(r)return r}else{if("ArrowRight"===n)return h(t)?p(t)?c(t):(o(r,!0),t):t;if("ArrowUp"===n){const e=(e=>{const t=e.previousElementSibling;return t&&t instanceof HTMLLIElement?t:null})(t);if(e)return p(e)?u(e):e;const r=f(t);if(r&&r instanceof HTMLLIElement)return r}else if("ArrowLeft"===n){if(p(t))return o(r,!1),t;const e=f(t);if(e&&e instanceof HTMLLIElement)return e}}return t};var T=Object.freeze({__proto__:null,isExpandableNode:d,trackDOMNodeToTreeNode:a,getNodeChildren:N,getPathToTreeNode:w,findNextNodeForTreeOutlineKeyboardNavigation:v});const y=o.RenderCoordinator.RenderCoordinator.instance();class E extends Event{static eventName="itemselected";data;constructor(e){super(E.eventName,{bubbles:!0,composed:!0}),this.data={node:e}}}class S extends Event{static eventName="itemmouseover";data;constructor(e){super(S.eventName,{bubbles:!0,composed:!0}),this.data={node:e}}}class b extends Event{static eventName="itemmouseout";data;constructor(e){super(b.eventName,{bubbles:!0,composed:!0}),this.data={node:e}}}class x extends HTMLElement{static litTagName=t.literal`devtools-tree-outline`;#e=this.attachShadow({mode:"open"});#t=[];#r=new Map;#n=new WeakMap;#o=!1;#i=null;#d=null;#s=(e,r)=>("string"!=typeof e.treeNodeData&&console.warn(`The default TreeOutline renderer simply stringifies its given value. You passed in ${JSON.stringify(e.treeNodeData,null,2)}. Consider providing a different defaultRenderer that can handle nodes of this type.`),t.html`${String(e.treeNodeData)}`);#a;#l=!1;#c=!1;static get observedAttributes(){return["nowrap","toplevelbordercolor"]}attributeChangedCallback(e,t,r){switch(e){case"nowrap":this.setNodeKeyNoWrapCSSVariable(r);break;case"toplevelbordercolor":this.setTopLevelNodeBorderColorCSSVariable(r)}}connectedCallback(){this.setTopLevelNodeBorderColorCSSVariable(this.getAttribute("toplevelbordercolor")),this.setNodeKeyNoWrapCSSVariable(this.getAttribute("nowrap")),this.#e.adoptedStyleSheets=[i,r.Style.default]}get data(){return{tree:this.#t,defaultRenderer:this.#s}}set data(e){this.#s=e.defaultRenderer,this.#t=e.tree,this.#a=e.filter,this.#o||(this.#d=this.#t[0]),this.render()}async expandRecursively(e=2){await Promise.all(this.#t.map((t=>this.expandAndRecurse(t,0,e)))),await this.render()}async collapseAllNodes(){this.#r.clear(),await this.render()}async expandToAndSelectTreeNode(e){return this.expandToAndSelectTreeNodeId(e.id)}async expandToAndSelectTreeNodeId(e){const t=await w(this.#t,e);if(null===t)throw new Error(`Could not find node with id ${e} in the tree.`);t.forEach(((e,r)=>{r<t.length-1&&this.setNodeExpandedState(e,!0)})),this.#i=e,await this.render()}expandNodeIds(e){return e.forEach((e=>this.#r.set(e,!0))),this.render()}focusNodeId(e){return this.#i=e,this.render()}async collapseChildrenOfNode(e){const t=this.#n.get(e);t&&(await this.recursivelyCollapseTreeNodeChildren(t),await this.render())}setNodeKeyNoWrapCSSVariable(e){n.SetCSSProperty.set(this,"--override-key-whitespace-wrapping",null!==e?"nowrap":"initial")}setTopLevelNodeBorderColorCSSVariable(e){n.SetCSSProperty.set(this,"--override-top-node-border",e?`1px solid ${e}`:"")}async recursivelyCollapseTreeNodeChildren(e){if(!d(e)||!this.nodeIsExpanded(e))return;const t=await this.fetchNodeChildren(e),r=Promise.all(t.map((e=>this.recursivelyCollapseTreeNodeChildren(e))));await r,this.setNodeExpandedState(e,!1)}getSelectedTreeNode(){if(!this.#d)throw new Error("getSelectedNode was called but selectedTreeNode is null");return this.#d}async fetchNodeChildren(e){const t=await N(e);if(!this.#a)return t;const r=[];for(const e of t){const t=this.#a(e.treeNodeData);if("SHOW"===t||this.isSelectedNode(e)||e.id===this.#i)r.push(e);else if("FLATTEN"===t&&d(e)){const t=await this.fetchNodeChildren(e);r.push(...t)}}return r}setNodeExpandedState(e,t){this.#r.set(e.id,t)}nodeIsExpanded(e){return this.#r.get(e.id)||!1}async expandAndRecurse(e,t,r){if(!d(e))return;if(this.setNodeExpandedState(e,!0),t===r||!d(e))return;const n=await this.fetchNodeChildren(e);await Promise.all(n.map((e=>this.expandAndRecurse(e,t+1,r))))}onArrowClick(e){return t=>{t.stopPropagation(),d(e)&&(this.setNodeExpandedState(e,!this.nodeIsExpanded(e)),this.render())}}onNodeClick(e){e.stopPropagation();const t=null!==this.getAttribute("clickabletitle"),r=e.currentTarget,n=this.#n.get(r);t&&n&&d(n)&&this.setNodeExpandedState(n,!this.nodeIsExpanded(n)),this.focusTreeNode(r)}async focusTreeNode(e){const t=this.#n.get(e);t&&(this.#d=t,await this.render(),this.dispatchEvent(new E(t)),y.write("DOMNode focus",(()=>{e.focus()})))}processHomeAndEndKeysNavigation(e){if("Home"===e){const e=this.#e.querySelector('ul[role="tree"] > li[role="treeitem"]');e&&this.focusTreeNode(e)}else if("End"===e){const e=this.#e.querySelectorAll('li[role="treeitem"]'),t=e[e.length-1];t&&this.focusTreeNode(t)}}async processArrowKeyNavigation(e,t){const r=this.#n.get(t);if(!r)return;const n=v({currentDOMNode:t,currentTreeNode:r,direction:e,setNodeExpandedState:(e,t)=>this.setNodeExpandedState(e,t)});await this.focusTreeNode(n)}processEnterOrSpaceNavigation(e){const t=this.#n.get(e);if(t&&d(t)){const e=this.nodeIsExpanded(t);this.setNodeExpandedState(t,!e),this.render()}}async onTreeKeyDown(t){if(!(t.target instanceof HTMLLIElement))throw new Error("event.target was not an <li> element");"Home"===t.key||"End"===t.key?(t.preventDefault(),this.processHomeAndEndKeysNavigation(t.key)):e.KeyboardUtilities.keyIsArrowKey(t.key)?(t.preventDefault(),await this.processArrowKeyNavigation(t.key,t.target)):"Enter"!==t.key&&" "!==t.key||(t.preventDefault(),this.processEnterOrSpaceNavigation(t.target))}focusPendingNode(e){this.#i=null,this.focusTreeNode(e)}isSelectedNode(e){return!!this.#d&&e.id===this.#d.id}renderNode(e,{depth:r,setSize:o,positionInSet:i}){let s;const l=this.nodeIsExpanded(e);if(d(e)&&l){const n=this.fetchNodeChildren(e).then((e=>e.map(((t,n)=>this.renderNode(t,{depth:r+1,setSize:e.length,positionInSet:n})))));s=t.html`<ul role="group">${t.Directives.until(n)}</ul>`}else s=t.nothing;const c=this.getSelectedTreeNode()===e?0:-1,h=t.Directives.classMap({expanded:d(e)&&l,parent:d(e),selected:this.isSelectedNode(e),"is-top-level":0===r}),p=t.Directives.ifDefined(d(e)?String(l):void 0);let u;return u=e.renderer?e.renderer(e,{isExpanded:l}):this.#s(e,{isExpanded:l}),t.html` <li role="treeitem" tabindex="${c}" aria-setsize="${o}" aria-expanded="${p}" aria-level="${r+1}" aria-posinset="${i+1}" class="${h}" @click="${this.onNodeClick}" track-dom-node-to-tree-node="${a(this.#n,e)}" on-render="${n.Directives.nodeRenderedCallback((t=>{t instanceof HTMLLIElement&&this.#i&&e.id===this.#i&&this.focusPendingNode(t)}))}"> <span class="arrow-and-key-wrapper" @mouseover="${()=>{this.dispatchEvent(new S(e))}}" @mouseout="${()=>{this.dispatchEvent(new b(e))}}"> <span class="arrow-icon" @click="${this.onArrowClick(e)}"> </span> <span class="tree-node-key" data-node-key="${e.treeNodeData}">${u}</span> </span> ${s} </li> `}async render(){if(!this.#l)return this.#l=!0,await y.write("TreeOutline render",(()=>{t.render(t.html` <div class="wrapping-container"> <ul role="tree" @keydown="${this.onTreeKeyDown}"> ${this.#t.map(((e,t)=>this.renderNode(e,{depth:0,setSize:this.#t.length,positionInSet:t})))} </ul> </div> `,this.#e,{host:this})})),this.#o=!0,this.#l=!1,this.#c?(this.#c=!1,this.render()):void 0;this.#c=!0}}n.CustomElements.defineComponent("devtools-tree-outline",x);var k=Object.freeze({__proto__:null,defaultRenderer:function(e){return t.html`${e.treeNodeData}`},ItemSelectedEvent:E,ItemMouseOverEvent:S,ItemMouseOutEvent:b,TreeOutline:x});export{k as TreeOutline,T as TreeOutlineUtils};
